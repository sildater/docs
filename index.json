[{"authors":null,"categories":null,"content":"Introduction The principal aim of the partitura package is to handle richly structured musical information as conveyed by modern staff music notation. It provides a much wider range of possibilities to deal with music than the more reductive (but very common) pianoroll-oriented approach inspired by the MIDI standard.\nSpecifically, the package allows for representing a variety of information in musical scores beyond the onset, duration and MIDI pitch numbers of notes, such as:\n pitch spellings, symbolic duration categories, and voicing information.  Moreover, it supports musical notions that are not note-related, like:\n measures, tempo indications, performance directions, repeat structures, and time/key signatures.  In addition to handling score information, the package can load MIDI recordings of performed scores, and alignments between scores and performances.\nSupported file types Musical data can be loaded from and saved to MusicXML and MIDI files. Furthermore, partitura uses MuseScore \u0026lt;https://musescore.org/\u0026gt;_ as a backend to load files in other formats, like MuseScore, MuseData, and GuitarPro. This requires a working installation of MuseScore on your computer. MEI format is currently not supported, but support is planned for a future release.\nScore-performance alignments can be read from different file types by partitura. Firstly it supports reading from the Matchfile format used by the publicly available\n[Vienna4x22 piano corpus research dataset]: https://repo.mdw.ac.at/projects/IWK/the_vienna_4x22_piano_corpus/data/index.html\t\u0026ldquo;Vienna4x22\u0026rdquo; .Secondly there is read support for Match and Corresp files produced by Nakamura\u0026rsquo;s \u0026quot; [music alignment software]: https://midialignment.github.io/demo.html\t\u0026ldquo;Nakamura\u0026rdquo;\nConceptual Overview This section offers some conceptual and design considerations that may be helpful when working with the package.\nRepresenting score information The package defines a musical ontology to describe musical scores that roughly follows the elements defined by the\nMore specifically, the elements of a musical score are represented as a collection of instances of classes like Note, Measure, Slur, and Rest. These instances are attached to an instance of class Part, which corresponds to the role of an instrument in a musical score. A part may contain one or more staffs, depending on the instrument.\nIn contrast to MusicXML documents, where musical time is largely implicit, time plays a crucial role in the representation of scores in partitura. Musical elements are associated to a Part instance by specifying their start (and possibly end) times. The Part instance thus acts as a timeline consisting of a number of discrete timepoints, each of which holds references to the musical elements starting and ending at that time. The musical elements themselves contain references to their respective starting and ending timepoints. Other than that, cross-references between musical elements are used sparingly, to keep the API simple.\nMusical elements in a Part can be filtered by class and iterated over, either from a particular timepoint onward or backward, or within a specified range. For example to find the measure to which a note belongs, you would iterate backwards over elements of class Measure that start at or before the start time of the note and select the first element of that iteration.\nScore vs. performance Although the MIDI format can be used to represent both score-related (key/time signatures, tempo) and performance-related information (expressive timing, dynamics), partitura regards a MIDI file as a representation of either a a score or a performance. Therefore is has separate functions to load and save scores (:func:~partitura.load_score_midi, :func:~partitura.save_score_midi) and performances (:func:~partitura.load_performance_midi, :func:~partitura.save_performance_midi). :func:~partitura.load_score_midi offers simple quantization for unquantized MIDIs but in general you should not expect a MIDI representation of a performance to be loaded correctly as a Part instance.\nRelation to The music21 package has been around since 2008, and is one of the few python packages available for working with symbolic musical data. It is both more mature and more elaborate than partitura. The aims of partitura are different from and more modest than those of music21, which aims to provide a toolkit for computer-aided musicology. Instead, partitura intends to provide a convenient way to work with symbolic musical data in the context of problems such as musical expression modeling, or music generation. Although it is not the main aim of the package to provide music analysis tools, the package does offer functionality for pitch spelling, voice assignment and key estimation.courses/example/ from [menu.example] to [menu.\u0026lt;NewFolderName\u0026gt;].\n","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"2cf40f65f4b0d0ab8e8628d9050f8a8e","permalink":"http://sildater.github.io/docs/partitura/handle-.match/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/docs/partitura/handle-.match/","section":"partitura","summary":"Learn how to use Partitura to easily parse and create match files.","tags":null,"title":"Handle .match","type":"book"},{"authors":null,"categories":null,"content":"A match file is distinguished in three main parts. The first part at the beginning of the file contains meta-information such as versioning, names and tags, and score related information, i.e., key signature, time signature, etc. The second part is the main core of the document and contains note-wise alignments, as well as deletions and insertions entries. The third and last part is found at the end of the document and contains all listed sustain pedal events with their MIDI cc values.\n","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"ea71e4dae494769ada8238d76a91a872","permalink":"http://sildater.github.io/docs/match/introduction/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/docs/match/introduction/","section":"match","summary":"Introduction","tags":null,"title":"Match File Format","type":"book"},{"authors":null,"categories":null,"content":"Flexibility Document everything!\nThis feature can be used for publishing content such as:\n Online courses Project or software documentation Tutorials Notes  The courses folder may be renamed. For example, we can rename it to docs for software/project documentation or tutorials for creating an online course.\nDelete courses To remove these pages, delete the courses folder and see below to delete the associated menu link.\nUpdate site menu After renaming or deleting the courses folder, you may wish to update any [[main]] menu links to it by editing your menu configuration at config/_default/menus.toml.\nFor example, if you delete this folder, you can remove the following from your menu configuration:\n[[main]] name = \u0026quot;Courses\u0026quot; url = \u0026quot;courses/\u0026quot; weight = 50  Or, if you are creating a software documentation site, you can rename the courses folder to docs and update the associated Courses menu configuration to:\n[[main]] name = \u0026quot;Docs\u0026quot; url = \u0026quot;docs/\u0026quot; weight = 50  Update the docs menu If you use the docs layout, note that the name of the menu in the front matter should be in the form [menu.X] where X is the folder name. Hence, if you rename the courses/example/ folder, you should also rename the menu definitions in the front matter of files within courses/example/ from [menu.example] to [menu.\u0026lt;NewFolderName\u0026gt;].\n","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"2a96191fcd7269b29c5a0c061a51eca7","permalink":"http://sildater.github.io/docs/partitura/introduction/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/docs/partitura/introduction/","section":"partitura","summary":"Learn how to use the Partitura python package.","tags":null,"title":"Introduction","type":"book"},{"authors":null,"categories":null,"content":"Introduction The principal aim of the partitura package is to handle richly structured musical information as conveyed by modern staff music notation. It provides a much wider range of possibilities to deal with music than the more reductive (but very common) pianoroll-oriented approach inspired by the MIDI standard.\nSpecifically, the package allows for representing a variety of information in musical scores beyond the onset, duration and MIDI pitch numbers of notes, such as:\n pitch spellings, symbolic duration categories, and voicing information.  Moreover, it supports musical notions that are not note-related, like:\n measures, tempo indications, performance directions, repeat structures, and time/key signatures.  In addition to handling score information, the package can load MIDI recordings of performed scores, and alignments between scores and performances.\nSupported file types Musical data can be loaded from and saved to MusicXML and MIDI files. Furthermore, partitura uses MuseScore \u0026lt;https://musescore.org/\u0026gt;_ as a backend to load files in other formats, like MuseScore, MuseData, and GuitarPro. This requires a working installation of MuseScore on your computer. MEI format is currently not supported, but support is planned for a future release.\nScore-performance alignments can be read from different file types by partitura. Firstly it supports reading from the Matchfile format used by the publicly available\n[Vienna4x22 piano corpus research dataset]: https://repo.mdw.ac.at/projects/IWK/the_vienna_4x22_piano_corpus/data/index.html\t\u0026ldquo;Vienna4x22\u0026rdquo; .Secondly there is read support for Match and Corresp files produced by Nakamura\u0026rsquo;s \u0026quot; [music alignment software]: https://midialignment.github.io/demo.html\t\u0026ldquo;Nakamura\u0026rdquo;\nConceptual Overview This section offers some conceptual and design considerations that may be helpful when working with the package.\nRepresenting score information The package defines a musical ontology to describe musical scores that roughly follows the elements defined by the\nMore specifically, the elements of a musical score are represented as a collection of instances of classes like Note, Measure, Slur, and Rest. These instances are attached to an instance of class Part, which corresponds to the role of an instrument in a musical score. A part may contain one or more staffs, depending on the instrument.\nIn contrast to MusicXML documents, where musical time is largely implicit, time plays a crucial role in the representation of scores in partitura. Musical elements are associated to a Part instance by specifying their start (and possibly end) times. The Part instance thus acts as a timeline consisting of a number of discrete timepoints, each of which holds references to the musical elements starting and ending at that time. The musical elements themselves contain references to their respective starting and ending timepoints. Other than that, cross-references between musical elements are used sparingly, to keep the API simple.\nMusical elements in a Part can be filtered by class and iterated over, either from a particular timepoint onward or backward, or within a specified range. For example to find the measure to which a note belongs, you would iterate backwards over elements of class Measure that start at or before the start time of the note and select the first element of that iteration.\nScore vs. performance Although the MIDI format can be used to represent both score-related (key/time signatures, tempo) and performance-related information (expressive timing, dynamics), partitura regards a MIDI file as a representation of either a a score or a performance. Therefore is has separate functions to load and save scores (:func:~partitura.load_score_midi, :func:~partitura.save_score_midi) and performances (:func:~partitura.load_performance_midi, :func:~partitura.save_performance_midi). :func:~partitura.load_score_midi offers simple quantization for unquantized MIDIs but in general you should not expect a MIDI representation of a performance to be loaded correctly as a Part instance.\nRelation to The music21 package has been around since 2008, and is one of the few python packages available for working with symbolic musical data. It is both more mature and more elaborate than partitura. The aims of partitura are different from and more modest than those of music21, which aims to provide a toolkit for computer-aided musicology. Instead, partitura intends to provide a convenient way to work with symbolic musical data in the context of problems such as musical expression modeling, or music generation. Although it is not the main aim of the package to provide music analysis tools, the package does offer functionality for pitch spelling, voice assignment and key estimation.courses/example/ from [menu.example] to [menu.\u0026lt;NewFolderName\u0026gt;].\n","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"0b723d04d88165ec32b249ffc163e146","permalink":"http://sildater.github.io/docs/match/usage/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/docs/match/usage/","section":"match","summary":"Learn how to use the match file format.","tags":null,"title":"Partitura","type":"book"},{"authors":null,"categories":null,"content":"Global Information Lines    Syntax Value type Mandatory Description     info(matchFileVersion,value). string  Matchfile version (current 1.0.0 previous 5.0, see version changes)   info(piece,value). string  Piece name or opus number   info(scoreFileName,value). string  Corresponding score file name (e.g. musicxml)   info(scoreFilePath,value). string  Corresponding score file path   info(midiFileName,value). string  Corresponding MIDIfile name   info(midiFilePath,value). string  Corresponding MIDI file path   info(audioFileName,value). string  Corresponding audio file name   info(audioFilePath,value). string  Corresponding audio file path   info(audioFirstNote,value). float  Time of first note onset in audio file   info(audioLastNote,value). float  Time of last note onset in audio file   info(performer,value). string  Performer name   info(composer,value). string  Composer name   info(midiClockUnits,value). integer  MIDI Clock Units (MIDI parts per quarter)   info(midiClockRate,value). integer  MIDI Clock Rate (Microseconds per quarter)   info(keySignature,value). [string]  deprecated (first) Key signature (see score properties)   info(timeSignature,value). [integer / integer]  deprecated (first) Time signature (see score properties)   info(beatSubdivision,value). [int]  deprecated Beat subdivision (see score properties)   info(tempoIndication,value). [string]  deprecated Tempo directions (see score properties)   info(approximateTempo,value). float  Approximate tempo   info(subtitle,value). string  Subtitles    Score Property Lines Time Signature: scoreprop(timeSignature,TimeSigValue,Measure:Beat,Offset,Duration,OnsetInBeats).\nKey Signature: scoreprop(keySignature,KeySigValue,Measure:Beat,Offset,Duration,OnsetInBeats).\nBeat Subdivision: scoreprop(beatSubDivision,BeatSubValue,Measure:Beat,Offset,Duration,OnsetInBeats).\nDirections: scoreprop(directions,DirectionsValue,Measure:Beat,Offset,Duration,OnsetInBeats).\n   Value name Value type Description     Measure integer measure number (starting at 1, 0 for anacrusis) of the score position   Beat integer integer beat number (starting at 1) of the score position   Offset Integer / integer offset of the score position****from beat position (in symbolic duration; fraction of whole notes)   OnsetInBeats float score position in contiguous beats (beat 0 = start of measure 1, beat unit = time signature denominator)   TimeSigValue integer / integer Time signature   KeySigValue  Key signature   BeatSubValue Integer ?   DirectionsValue [string] A list of performance directions    Section Lines Section in the score with reference positions in the underlying (non-unfolded) score: section(StartInBeatsUnfolded,EndInBeatsUnfolded, StartInBeatsOriginal, EndInBeatsOriginal, RepeatEndType).\nPossible values:\n   Value name Value type Description     StartInBeatsUnfolded float Start of the segment in beats in unfolded score time   EndInBeatsUnfolded float End of the segment in beats in the unfolded score time   StartInBeatsOriginal float Start of the segment in beats in the original score   EndInBeatsOriginal float End of the segment in beats in the original score   RepeatEndType [string] optional: list of type of the end of segment, e.g. ‚Äúfine‚Äù ‚Äúrepeat left‚Äù, ‚Äúvolta end‚Äù, etc.    Match Lines Beat, downbeat, or any score position annotation between performance and score: stime(Measure:Beat,Offset,OnsetInBeats,AnnotationType)-ptime(Onsets).\n   Value name Value type Description     Measure integer measure number (starting at 1, 0 for anacrusis) of the score position   Beat integer integer beat number (starting at 1) of the score position   Offset Integer / integer offset of the score position****from beat position (in symbolic duration; fraction of whole notes)   OnsetInBeats float score position in contiguous beats (beat 0 = start of measure 1, beat unit = time signature denominator)   AnnotationType [string] Optional: list of types of annotation, e.g. ‚Äúbeat‚Äù, ‚Äúmeasure‚Äù, or ‚Äúdownbeat‚Äù   Onsets [integer] Array of at least one time in parts/ticks of the performance annotation corresponding to the score position    Notes in the performance:\nnote(ID,MIDIpitch,Onset,Offset,Velocity).\n   Value name Value type Description     ID integer Note identifier   MIDIpitch integer Pitch 0-127   Onset integer Time in parts/ticks of the note on message   Offset integer Time in parts/ticks of the note off message   adjustedOffset integer deprecated Sounding note off when adjusted by sustain pedal information (see pedal lines)   Velocity integer Note on velocity 0-127    Notes in the score snote(Anchor,[NoteName,Modifier],Octave,Measure:Beat,Offset,Duration,OnsetInBeats,OffsetInBeats,ScoreAttributesList).\n   Value name Value type Description     Anchor string Note identifier (we should specifically reserve ‚Äú-‚Äù at the end of the anchor as ‚Äúrepetition‚Äù)   NoteName string Pitch class name in [C, D, E, F, G, A, B]   Modifier string pitch modifier in [‚Äú‚Äù, n, b, #, bb, x]   Octave integer octave number (scientific notation, middle C is in octave 4)   Measure integer measure number (starting at 1, 0 for anacrusis)   Beat integer integer beat number of note onset (starting at 1)   Offset integer / integer offset from beat position (in symbolic duration; fraction of whole notes)   OnsetInBeats float onset position in contiguous beats (beat 0 = start of measure 1, beat unit = time signature denominator)   DurationInBeats float duration in beats   ScoreAttributesList [string] note attributes (‚Äúgrace‚Äù, ‚Äúappoggiatura‚Äù, etc.)    score note matched to a performed note: snote( _ , ‚Ä¶ , _ )-note( _ , ‚Ä¶ , _ ).\nsnote(Anchor,NoteName,Modifier],Octave,Measure:Beat,Offset,Duration,OnsetInBeats,OffsetInBeats,ScoreAttributesList)-note(ID,MIDIpitch,Onset,Offset,Velocity).\n   Value name Value type Description     Anchor string Note identifier (we should specifically reserve ‚Äú-‚Äù at the end of the anchor as ‚Äúrepetition‚Äù)   NoteName string Pitch class name in [C, D, E, F, G, A, B]   Modifier string pitch modifier in [‚Äú‚Äù, n, b, #, bb, x]   Octave integer octave number (scientific notation, middle C is in octave 4)   Measure integer measure number (starting at 1, 0 for anacrusis)   Beat integer integer beat number of note onset (starting at 1)   Offset integer / integer offset from beat position (in symbolic duration; fraction of whole notes)   OnsetInBeats float onset position in contiguous beats (beat 0 = start of measure 1, beat unit = time signature denominator)   DurationInBeats float duration in beats   ScoreAttributesList [string] note attributes (‚Äúgrace‚Äù, ‚Äúappoggiatura‚Äù, etc.)   ID integer Note identifier   MIDIpitch integer Pitch 0-127   Onset integer Time in parts/ticks of the note on message   Offset integer Time in parts/ticks of the note off message   adjustedOffset integer deprecated Sounding note off when adjusted by sustain pedal information (see pedal lines)   Velocity integer Note on velocity 0-127    Omitted score note Score notes that were omitted in the performance:\nsnote( _ , ‚Ä¶ , _ )-deletion.\nInserted Performed note: Performed notes that are not found in the score:\ninsertion-note( _ , ‚Ä¶ , _ ).\nPedal Lines Pedal lines represent MIDI cc 64 (sustain pedal) messages in the performance MIDI file.\nPedal line:\nsustain(Time,Value).\n   Value name Value type Description     Time integer Time in parts/ticks of the pedal message   Value integer Sustain pedal value 0-127    ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"0cb1a9fab15bff21672303dc694dc34e","permalink":"http://sildater.github.io/docs/match/specification/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/docs/match/specification/","section":"match","summary":"specification of the match file format.","tags":null,"title":"Match File Format","type":"book"},{"authors":null,"categories":null,"content":"Repetition Handling Some background Currently the repeat object is a simple TimedObject with start and end time.\nRepeat objects are read from xml barline objects with repeat and Volta brackets are read from barline objects with \u0026ldquo;ending\u0026rdquo; property in partitura.score.Ending obejects and have a number property.\nThis allows for the creation of ScoreVariants based on Repeats for the unfolding of parts.\nThere are several limit cases to unfolding/segmentation:\n the endpoint of Ending objects (encoding a Volta bracket) is not automatically inferred Volta brackets with \u0026gt;2 endings are not supported Nested repeats are not supported all other navigation marks (segno, coda, capo, fine, \u0026hellip;?) are not supported  The ScoreVariant itself allows for segment-type/jump-type-agnostic ScoreVariants. As far as I understand the ScoreVariant contains a segment list of the structure:\nsv.segments = [(0,6,0),(0,6,6)(6,10,12)]  where the three numbers mean (start of segment, end of segment, cumulative/unfolded start of segment)\nsee this example by Francesco:\nwhere the possible omissions of repeats lead to these four segment lists:\n[(0, 4, 0), (4, 6, 4), (6, 12, 6), (14, 22, 12)] [(0, 4, 0), (4, 6, 4), (6, 14, 6), (6, 12, 14), (14, 22, 20)] [(0, 4, 0), (0, 4, 4), (4, 6, 8), (6, 12, 10), (14, 22, 16)] [(0, 4, 0), (0, 4, 4), (4, 6, 8), (6, 14, 10), (6, 12, 18), (14, 22, 24)]  These segments and the corresponding ScoreVariants are created from the Repeat objects. As you can see the da capo and fine are ignored. but segments can also be added to a ScoreVariant, they are just defined by positions.\nmy proposal for a Segment object I think these problems of unfolding could be solved with a partitura.score.Segment object:\nclass Segment(TimedObject): \u0026quot;\u0026quot;\u0026quot;Class that represents any segment between two navigation markers Parameters ---------- id : int/string The ID associated with this segment jump_to : list of int/string The IDs of segments where the unfolded score could jump to at the end of this segment Attributes ---------- id : int/string See parameters jump_to : list of int/string See parameters jump_id : int the id \u0026quot;\u0026quot;\u0026quot; def __init__(self, id, jump_to): super().__init__() self.id = id self.jump_to = jump_to self.jump_id = 0  Let\u0026rsquo;s go back to the score example above. This part would contain 5 segments:\n the first 4 beats, let\u0026rsquo;s call it a the beats 4 - 6 : b 6 - 12 : c 12 - 14 : d 14 - 22 : e  and their jump_to properties would look like this:\na.jump_to = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;] b.jump_to = [\u0026quot;c\u0026quot;] c.jump_to = [\u0026quot;d\u0026quot;, \u0026quot;e\u0026quot;, end] d.jump_to = [\u0026quot;c\u0026quot;] e.jump_to = [\u0026quot;a\u0026quot;, end] # since it would be an option to not play the da capo?  ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"605a5579e13554efc57eac8a366213c2","permalink":"http://sildater.github.io/docs/partitura/repetition/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/docs/partitura/repetition/","section":"partitura","summary":"Learn how Partitura and the Match Format handles repetitions during the performance's score unfolding.","tags":null,"title":"Repetition Handling","type":"book"},{"authors":null,"categories":null,"content":"Repetition Handling Some background Currently the repeat object is a simple TimedObject with start and end time.\nRepeat objects are read from xml barline objects with repeat and Volta brackets are read from barline objects with \u0026ldquo;ending\u0026rdquo; property in partitura.score.Ending obejects and have a number property.\nThis allows for the creation of ScoreVariants based on Repeats for the unfolding of parts.\nThere are several limit cases to unfolding/segmentation:\n the endpoint of Ending objects (encoding a Volta bracket) is not automatically inferred Volta brackets with \u0026gt;2 endings are not supported Nested repeats are not supported all other navigation marks (segno, coda, capo, fine, \u0026hellip;?) are not supported  The ScoreVariant itself allows for segment-type/jump-type-agnostic ScoreVariants. As far as I understand the ScoreVariant contains a segment list of the structure:\nsv.segments = [(0,6,0),(0,6,6)(6,10,12)]  where the three numbers mean (start of segment, end of segment, cumulative/unfolded start of segment)\nsee this example by Francesco:\nwhere the possible omissions of repeats lead to these four segment lists:\n[(0, 4, 0), (4, 6, 4), (6, 12, 6), (14, 22, 12)] [(0, 4, 0), (4, 6, 4), (6, 14, 6), (6, 12, 14), (14, 22, 20)] [(0, 4, 0), (0, 4, 4), (4, 6, 8), (6, 12, 10), (14, 22, 16)] [(0, 4, 0), (0, 4, 4), (4, 6, 8), (6, 14, 10), (6, 12, 18), (14, 22, 24)]  These segments and the corresponding ScoreVariants are created from the Repeat objects. As you can see the da capo and fine are ignored. but segments can also be added to a ScoreVariant, they are just defined by positions.\nmy proposal for a Segment object I think these problems of unfolding could be solved with a partitura.score.Segment object:\nclass Segment(TimedObject): \u0026quot;\u0026quot;\u0026quot;Class that represents any segment between two navigation markers Parameters ---------- id : int/string The ID associated with this segment jump_to : list of int/string The IDs of segments where the unfolded score could jump to at the end of this segment Attributes ---------- id : int/string See parameters jump_to : list of int/string See parameters jump_id : int the id \u0026quot;\u0026quot;\u0026quot; def __init__(self, id, jump_to): super().__init__() self.id = id self.jump_to = jump_to self.jump_id = 0  Let\u0026rsquo;s go back to the score example above. This part would contain 5 segments:\n the first 4 beats, let\u0026rsquo;s call it a the beats 4 - 6 : b 6 - 12 : c 12 - 14 : d 14 - 22 : e  and their jump_to properties would look like this:\na.jump_to = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;] b.jump_to = [\u0026quot;c\u0026quot;] c.jump_to = [\u0026quot;d\u0026quot;, \u0026quot;e\u0026quot;, end] d.jump_to = [\u0026quot;c\u0026quot;] e.jump_to = [\u0026quot;a\u0026quot;, end] # since it would be an option to not play the da capo?  ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"f3b5c5fb223498b9498d04039db352d0","permalink":"http://sildater.github.io/docs/match/repetition/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/docs/match/repetition/","section":"match","summary":"Learn how Partitura and the Match Format handles repetitions during the performance's score unfolding.","tags":null,"title":"Repetition Handling","type":"book"},{"authors":null,"categories":null,"content":"Welcome to the Partitura python package Documentation to handle match files_!!!\n üëâ Get Started with the Introduction   ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"239ba76436829b68588ff9672e313616","permalink":"http://sildater.github.io/docs/partitura/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs/partitura/","section":"partitura","summary":"Welcome to the Partitura python package Documentation to handle match files_!!!\n üëâ Get Started with the Introduction   ","tags":null,"title":"Partitura Documentation","type":"book"},{"authors":null,"categories":null,"content":"Welcome to the Official Match Documentation!!!\n   Get Started with Match   ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"0129f426837c7ec67c512b7a32736fa4","permalink":"http://sildater.github.io/docs/match/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs/match/","section":"match","summary":"Welcome to the Official Match Documentation!!!\n   Get Started with Match   ","tags":null,"title":"The Match File Format","type":"book"}]